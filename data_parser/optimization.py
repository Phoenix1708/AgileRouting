from __future__ import division
from cvxopt import matrix, solvers


def optimise(num_of_servers, total_requests, prices, data_pre_req,
             bandwidths, service_caps, req_tp_coefs, k):
    """
    :param num_of_servers:  total number of receipts of client requests
    :param total_requests:  total number of requests generated by client
    :param prices:          list of pricing of every ELB involved
    :param data_pre_req:    the average amount of data transferred pre request
                            for requests received at *each recipients*

    :param bandwidths:      The capacity of links between client to
                            each recipients
    :param service_caps:    Maximum amount of requests that *each recipients*
                            can process before throughput drops
    :param req_tp_coefs:    list of coefficients, which reflect the number of
                            request and receipt throughput relationship,
                            for *each recipients*

    :param k:               coefficient to reflect on how much additional
                            cost to pay for one unit of throughput improvement
    :return:                The current best weight for each requests receipt
    """

    measurement_interval = 600  # 10 min - 600 seconds

    # Objective: (e.g number of service station = 2)
    # minimise  Cost + K * throughput
    #           vol * avg_data_pre_req[0] * prices[0] * alpha[0] +
    #           vol * avg_data_pre_req[1] * prices[0] * alpha[1] +
    #           K * vol * #requset_throughput_coefficient[0] * alpha[0] +
    #           K * vol * #requset_throughput_coefficient[1] * alpha[1]
    #
    #           i.e (vol * avg_data_pre_req[0] * prices[0] +
    #                K * vol * #requset_throughput_coefficient[0]) * alpha[0] +
    #               (vol * avg_data_pre_req[1] * prices[1] +
    #                K * vol * #requset_throughput_coefficient[1]) * alpha[1]
    #
    #
    # Subject to:
    #   (data/second < bandwidth of the link)
    #   (vol * avg_data * alpha[i]) / 10 min < bandwidth[i]
    #   i.e (vol * avg_data * alpha[i]) < bandwidths[i] * 10 min
    #
    #   (the number of requests on a link < the capacity of
    #   server before throughput drops)
    #   vol * alpha[i] <= serviceCaps[i]
    #
    #   Sum of alpha (weights) is 1
    #   alpha[0] + alpha[1] + ... alpha[numOfServers-1] = 1
    #
    # Variable: alpha

    coefficients = []
    # 2 kind of constrains for each alpha
    right_hand_side = [0.0] * ((2 * num_of_servers) + 1)
    # coefficients in objective function
    obj_func_coef = []

    idx = 0
    for i in xrange(num_of_servers):
        # 2 kind of constrains for each alpha
        coefficients_for_alpha_i = [0.0] * ((2 * num_of_servers) + 1)
        coefficients_for_alpha_i[idx] = float(total_requests * data_pre_req[i])
        coefficients_for_alpha_i[idx + 1] = float(total_requests)

        # coefficient for the "sum of alpha is 1" constrain
        coefficients_for_alpha_i[2 * num_of_servers] = 1.0

        # set the right hand side of the constrain
        right_hand_side[idx] = float(bandwidths[i] * measurement_interval)
        right_hand_side[idx + 1] = float(service_caps[i])

        # right hand side for the "sum of alpha is 1" constrain
        right_hand_side[2 * num_of_servers] = 1.0

        # put coefficients together as whole coefficients matrix
        # for constrains
        coefficients.append(coefficients_for_alpha_i)
        # objective coefficients
        obj_func_coef.append(float(total_requests * data_pre_req[i] * prices[i]
                                   + k * total_requests * req_tp_coefs[i]))
        idx += 2

    a = matrix(coefficients)
    b = matrix(right_hand_side)
    c = matrix(obj_func_coef)

    sol = solvers.lp(c, a, b)

    return sol['x']


if __name__ == '__main__':
    # A = matrix([[-1.0, -1.0, 0.0, 1.0], [1.0, -1.0, -1.0, -2.0]])
    # b = matrix([1.0, -2.0, 0.0, 4.0])
    # c = matrix([2.0, 1.0])
    # sol = solvers.lp(c, A, b)
    #
    # print(sol['x'])

    test = optimise(2, 1000, [0.008, 0.010], [29, 50], [100, 200], [50, 100],
                    [0.5, 0.6], 4/5)

    test2 = optimise(2, 1000, [0.008, 0.008], [29, 29], [100, 100],
                     [5000, 5000], [0.5, 0.5], 4/5)

    print test
    print test2